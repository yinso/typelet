// Generated by CoffeeScript 1.10.0
(function() {
  var Builder, Type, TypeEnv, util;

  Type = require('./type');

  util = require('./util');

  TypeEnv = require('./type-env');

  Builder = (function() {
    function Builder() {
      if (!(this instanceof Builder)) {
        return new Builder();
      }
    }

    Builder.prototype.build = function(schema, env) {
      var item, key, ref1;
      if (env == null) {
        env = new TypeEnv();
      }
      if (schema.hasOwnProperty('definitions') && (schema.definitions instanceof Object)) {
        ref1 = schema.definitions;
        for (key in ref1) {
          item = ref1[key];
          env.define(key, this.buildOne(item, env, schema));
        }
      } else {
        this.buildOne(schema, env, schema);
      }
      return env;
    };

    Builder.prototype.buildOne = function(schema, env, top) {
      var type;
      type = (function() {
        switch (schema.type) {
          case 'integer':
            return this._integer(schema, env, top);
          case 'number':
            return this._float(schema, env, top);
          case 'string':
            return this._string(schema, env, top);
          case 'boolean':
            return this._boolean(schema, env, top);
          case 'null':
            return this._null(schema, env, top);
          case 'array':
            return this._array(schema, env, top);
          case 'object':
            return this._object(schema, env, top);
          default:
            if (schema.type instanceof Array) {
              return this.buildOneOfTypes(schema, env, top);
            } else if (schema.$ref) {
              return this._ref(schema, env, top);
            } else if (schema.oneOf) {
              return this.buildOneOf(schema, env, top);
            } else {
              throw new Error("Compiler:unknown_type: " + schema.type);
            }
        }
      }).call(this);
      if (schema["default"]) {
        return Type.PropertyType(null, type, schema["default"]);
      } else {
        return type;
      }
    };

    Builder.prototype._integer = function(schema, env, top) {
      return Type.Integer;
    };

    Builder.prototype._float = function(schema, env, top) {
      return Type.Float;
    };

    Builder.prototype._boolean = function(schema, env, top) {
      return Type.Boolean;
    };

    Builder.prototype._null = function(schema, env, top) {
      return Type.Null;
    };

    Builder.prototype._string = function(schema, env, top) {
      return Type.String;
    };

    Builder.prototype.buildOneOfTypes = function(schema, env, top) {
      var type, types;
      types = (function() {
        var i, len, ref1, results;
        ref1 = schema.type;
        results = [];
        for (i = 0, len = ref1.length; i < len; i++) {
          type = ref1[i];
          results.push(this.buildOne({
            type: type
          }, env, top));
        }
        return results;
      }).call(this);
      return Type.OneOfType(types);
    };

    Builder.prototype.buildOneOf = function(schema, env, top) {
      var type, types;
      types = (function() {
        var i, len, ref1, results;
        ref1 = schema.oneOf || [];
        results = [];
        for (i = 0, len = ref1.length; i < len; i++) {
          type = ref1[i];
          results.push(this.buildOne(type, env, top));
        }
        return results;
      }).call(this);
      return Type.OneOfType(types);
    };

    Builder.prototype._array = function(schema, env, top) {
      var itemType;
      itemType = this.buildOne(schema.items, env, top);
      return Type.ArrayType(itemType);
    };

    Builder.prototype._object = function(schema, env, top) {
      var inner, key, props;
      props = (function() {
        var ref1, results;
        ref1 = schema.properties || {};
        results = [];
        for (key in ref1) {
          inner = ref1[key];
          results.push(Type.PropertyType(key, this.buildOne(inner, env, top)));
        }
        return results;
      }).call(this);
      return Type.ObjectType(props);
    };

    Builder.prototype._ref = function(schema, env, top) {
      var name;
      name = this._parseRef(schema.$ref);
      return env.get(name);
    };

    Builder.prototype._parseRef = function(ref) {
      var parsed;
      parsed = ref.split('/');
      return parsed[parsed.length - 1];
    };

    return Builder;

  })();

  util._mixin(Type, {
    JsonSchema: Builder()
  });

  module.exports = Builder;

}).call(this);
