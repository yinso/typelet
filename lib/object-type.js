// Generated by CoffeeScript 1.10.0
(function() {
  var ObjectType, PropertyType, Type, errLib, util,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  util = require('./util');

  errLib = require('./error');

  Type = require('./type');

  PropertyType = require('./property-type');

  ObjectType = (function(superClass) {
    extend(ObjectType, superClass);

    function ObjectType(properties) {
      var j, key, len, options, prop, type;
      if (properties == null) {
        properties = [];
      }
      if (!(this instanceof ObjectType)) {
        return new ObjectType(properties);
      }
      ObjectType.__super__.constructor.call(this);
      options = {
        typeID: Type.typeID++,
        properties: {},
        ordered: []
      };
      util._mixin(this, options);
      if (properties instanceof Array) {
        for (j = 0, len = properties.length; j < len; j++) {
          prop = properties[j];
          this.append(prop);
        }
      } else if (properties instanceof Object) {
        for (key in properties) {
          type = properties[key];
          if (properties.hasOwnProperty(key)) {
            if (!(type instanceof Type)) {
              throw new Error("invalid_property_type: " + type);
            }
          }
          this.set(key, type);
        }
      } else {
        throw new Error("invalid_object_type_properties: must_be_array_of_property_types_or_object_of_types");
      }
    }

    ObjectType.prototype.typeCategory = 'Object';

    ObjectType.prototype.isGeneric = function() {
      var j, len, prop, ref;
      ref = this.properties;
      for (j = 0, len = ref.length; j < len; j++) {
        prop = ref[j];
        if (prop.isGeneric()) {
          return true;
        }
      }
      return false;
    };

    ObjectType.prototype.isComposite = function() {
      return true;
    };

    ObjectType.prototype.build = ObjectType;

    ObjectType.prototype.isa = function(obj) {
      var j, len, prop, ref;
      if (this.outerIsa(obj)) {
        ref = this.ordered;
        for (j = 0, len = ref.length; j < len; j++) {
          prop = ref[j];
          if (!prop.isa(obj[prop.name])) {
            return false;
          }
        }
        return true;
      } else {
        return false;
      }
    };

    ObjectType.prototype.outerIsa = function(obj) {
      return obj instanceof Object;
    };

    ObjectType.prototype._convert = function(obj, error, path, isExplicit) {
      var j, len, prop, ref, result;
      result = {};
      ref = this.ordered;
      for (j = 0, len = ref.length; j < len; j++) {
        prop = ref[j];
        result[prop.name] = prop._convert(obj[prop.name], path + "/" + prop.name, isExplicit);
      }
      return result;
    };

    ObjectType.prototype.canAssignFrom = function(type) {
      var i, j, len, prop, sorted, sortedB;
      if (type instanceof ObjectType) {
        sorted = this._sortedProperties();
        sortedB = type._sortedProperties();
        if (sortedB.length < sorted.length) {
          false;
        }
        for (i = j = 0, len = sorted.length; j < len; i = ++j) {
          prop = sorted[i];
          if (!prop.canAssignFrom(sortedB[i])) {
            return false;
          }
        }
        return true;
      } else {
        return false;
      }
    };

    ObjectType.prototype.resolve = function(obj, resolver) {
      var key, props, val;
      props = (function() {
        var results;
        results = [];
        for (key in obj) {
          val = obj[key];
          results.push(PropertyType(key, resolver.resolve(val)));
        }
        return results;
      })();
      return ObjectType(props);
    };

    ObjectType.prototype._sortedProperties = function() {
      return [].concat(this.ordered).sort(function(a, b) {
        return a.name > b.name;
      });
    };

    ObjectType.prototype.equal = function(type) {
      var i, j, len, prop, sortedA, sortedB;
      if (type instanceof ObjectType) {
        if (this.ordered.length !== type.ordered.length) {
          return false;
        }
        sortedA = this._sortedProperties();
        sortedB = type._sortedProperties();
        for (i = j = 0, len = sortedA.length; j < len; i = ++j) {
          prop = sortedA[i];
          if (!prop.equal(sortedB[i])) {
            return false;
          }
        }
        return true;
      } else {
        return false;
      }
    };

    ObjectType.prototype._toString = function(env) {
      var prop, props;
      props = (function() {
        var j, len, ref, results;
        ref = this.ordered;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          prop = ref[j];
          results.push(prop._toString(env));
        }
        return results;
      }).call(this);
      return "Object[" + (props.join(',')) + "]";
    };

    ObjectType.prototype.has = function(key) {
      return this.properties.hasOwnProperty(key);
    };

    ObjectType.prototype.get = function(key) {
      if (this.has(key)) {
        return this.properties[key];
      } else {
        throw new Error("ObjectType.get:unknown_key: " + key);
      }
    };

    ObjectType.prototype.set = function(key, type) {
      return this.append(Type.PropertyType(key, type));
    };

    ObjectType.prototype.append = function(prop) {
      if (!(prop instanceof Type) && prop.typeCategory === 'Property') {
        throw new Error("invalid_property_type: " + prop);
      }
      if (this.has(prop.name)) {
        throw new Error("object_type_duplicate_property: " + prop.name);
      }
      this.properties[prop.name] = prop;
      return this.ordered.push(prop);
    };

    return ObjectType;

  })(Type);

  Type.attachType(Object, ObjectType());

  util._mixin(Type, {
    ObjectType: ObjectType
  });

  module.exports = ObjectType;

}).call(this);
