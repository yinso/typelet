// Generated by CoffeeScript 1.10.0
(function() {
  var ASTLet, BinaryExp, Check, Compiler, LiteralExp, MemberExp, NotExp, ProcedureExp, RefExp, SymbolExp, util;

  util = require('./util');

  ASTLet = require('astlet');

  ({
    $params: [
      {
        $symbol: 'foo'
      }, {
        $symbol: 'bar'
      }
    ],
    $body: {
      $eq: {
        $lhs: {
          $symbol: 'foo'
        },
        $rhs: {
          $symbol: 'bar'
        }
      }
    }
  });

  Check = (function() {
    function Check(exp, check) {
      if (!(this instanceof Check)) {
        return new Check(exp, check);
      }
      this.exp = exp;
      this.check = check;
    }

    Check.compile = function(exp) {
      var body, param, params, proc;
      if (!(exp.$params && exp.$body)) {
        throw new Error("Check.compile:toplevel_require_$params_and_$body");
      }
      params = (function() {
        var i, len, ref, results;
        ref = exp.$params;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          param = ref[i];
          results.push(this._compileOne(param));
        }
        return results;
      }).call(this);
      body = this._compileOne(exp.$body);
      this._verifyBody(params, body);
      proc = ProcedureExp(params, body).compile();
      return new this(exp, proc);
    };

    Check._verifyBody = function(params, body) {};

    Check._compileOne = function(exp) {
      var head, key;
      if (exp.$symbol) {
        return SymbolExp(exp.$symbol);
      } else if (exp.$literal) {
        return LiteralExp(exp.$literal);
      } else if (exp.$member) {
        head = this._compileOne(exp.$member.head);
        key = LiteralExp(exp.$member.key);
        return MemberExp(head, key);
      } else if (exp.$eq) {
        return BinaryExp(SymbolExp('=='), this._compileOne(exp.$eq.lhs), this._compileOne(exp.$eq.rhs));
      } else if (exp.$ne) {
        return BinaryExp(SymbolExp('!='), this._compileOne(exp.$ne.lhs), this._compileOne(exp.$ne.rhs));
      } else if (exp.$gt) {
        return BinaryExp(SymbolExp('>'), this._compileOne(exp.$gt.lhs), this._compileOne(exp.$gt.rhs));
      } else if (exp.$gte) {
        return BinaryExp(SymbolExp('>='), this._compileOne(exp.$gte.lhs), this._compileOne(exp.$gte.rhs));
      } else if (exp.$lt) {
        return BinaryExp(SymbolExp('<'), this._compileOne(exp.$lt.lhs), this._compileOne(exp.$lt.rhs));
      } else if (exp.$lte) {
        return BinaryExp(SymbolExp('<='), this._compileOne(exp.$lte.lhs), this._compileOne(exp.$lte.rhs));
      } else if (exp.$and) {
        return BinaryExp(SymbolExp('&&'), this._compileOne(exp.$and.lhs), this._compileOne(exp.$and.rhs));
      } else if (exp.$or) {
        return BinaryExp(SymbolExp('||'), this._compileOne(exp.$or.lhs), this._compileOne(exp.$or.rhs));
      } else if (exp.$not) {
        return NotExp(this._compileOne(exp.$not));
      } else {
        throw new Error("Check.compile:unknown_type: " + exp);
      }
    };

    return Check;

  })();

  Compiler = (function() {
    function Compiler(exp) {
      var ast;
      ast = AST.load(exp);
      this.compile(ast);
    }

    Compiler.prototype.compile = function(ast) {
      var key;
      key = this.key(ast);
      if (Compiler.prototype.hasOwnProperty(key)) {
        return this[key](ast);
      }
    };

    Compiler.prototype._integer = function(ast) {
      return ast.value.toString();
    };

    Compiler.prototype._float = function(ast) {
      return ast.value.toString();
    };

    Compiler.prototype._string = function(ast) {
      return JSON.stringify(ast.value);
    };

    Compiler.prototype._boolean = function(ast) {
      return JSON.stringify(ast.value);
    };

    Compiler.prototype._date = function(ast) {
      return JSON.stringify(ast.value.toISOString());
    };

    Compiler.prototype._symbol = function(ast) {
      return ast.value.toString();
    };

    Compiler.prototype._regex = function(ast) {
      return JSON.stringify(ast.value.toString());
    };

    Compiler.prototype._null = function(ast) {
      return 'null';
    };

    Compiler.prototype._undefined = function(ast) {
      return 'undefined';
    };

    Compiler.prototype._unary = function(ast) {
      return '(' + this.compile(ast.op) + this.compile(ast.rhs) + ')';
    };

    Compiler.prototype._binary = function(ast) {
      return '(' + this.compile(ast.lhs) + this.compile(ast.op) + this.compile(ast.rhs) + ')';
    };

    Compiler.prototype._member = function(ast) {
      return '(' + this.compile(ast.head) + '.' + this.compile(ast.key) + ')';
    };

    return Compiler;

  })();

  SymbolExp = (function() {
    function SymbolExp(name) {
      if (!(this instanceof SymbolExp)) {
        return (function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor, result = func.apply(child, args);
          return Object(result) === result ? result : child;
        })(SymbolExp, arguments, function(){});
      }
      this.name = name;
    }

    SymbolExp.prototype.compile = function() {
      return this.name;
    };

    return SymbolExp;

  })();

  LiteralExp = (function() {
    function LiteralExp(value) {
      if (!(this instanceof LiteralExp)) {
        return (function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor, result = func.apply(child, args);
          return Object(result) === result ? result : child;
        })(LiteralExp, arguments, function(){});
      }
      this.value = value;
    }

    LiteralExp.prototype.compile = function() {
      if (this.value === void 0) {
        return 'undefined';
      } else {
        return JSON.stringify(this.value);
      }
    };

    return LiteralExp;

  })();

  BinaryExp = (function() {
    function BinaryExp(op, lhs, rhs) {
      if (!(this instanceof BinaryExp)) {
        return new BinaryExp(op, lhs, rhs);
      }
      this.op = op;
      this.lhs = lhs;
      this.rhs = rhs;
    }

    BinaryExp.prototype.compile = function() {
      return "(" + this.lhs.compile() + this.op.compile() + this.rhs.compile() + ")";
    };

    return BinaryExp;

  })();

  NotExp = (function() {
    function NotExp(inner) {
      if (!(this instanceof NotExp)) {
        return new NotExp(inner);
      }
      this.inner = inner;
    }

    NotExp.prototype.compile = function() {
      return "!(" + this.inner.compile() + ")";
    };

    return NotExp;

  })();

  RefExp = (function() {
    function RefExp(exp) {
      if (!(this instanceof RefExp)) {
        return new RefExp(exp);
      }
      this.exp = exp;
    }

    RefExp.prototype.compile = function() {
      return this.exp;
    };

    return RefExp;

  })();

  MemberExp = (function() {
    function MemberExp(head, key) {
      if (!(this instanceof MemberExp)) {
        return new MemberExp(head, key);
      }
      this.head = head;
      this.key = key;
    }

    MemberExp.prototype.compile = function() {
      return this.head.compile() + "[" + this.key.compile() + "]";
    };

    return MemberExp;

  })();

  ProcedureExp = (function() {
    function ProcedureExp(params, body) {
      if (!(this instanceof ProcedureExp)) {
        return new ProcedureExp(params, body);
      }
      this.params = params;
      this.body = body;
    }

    ProcedureExp.prototype.compile = function() {
      var body, param, params;
      params = (function() {
        var i, len, ref, results;
        ref = this.params;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          param = ref[i];
          results.push(param.compile());
        }
        return results;
      }).call(this);
      body = this.body.compile();
      return new Function(params, "return " + body);
    };

    return ProcedureExp;

  })();

  util._mixin(Check, {
    Symbol: SymbolExp,
    Literal: LiteralExp,
    Binary: BinaryExp,
    Not: NotExp,
    Ref: RefExp,
    Member: MemberExp,
    Procedure: ProcedureExp
  });

  Check = (function() {
    function Check() {}

    Check.compile = function(exp) {};

    return Check;

  })();

  module.exports = Check;

}).call(this);
