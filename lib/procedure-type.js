// Generated by CoffeeScript 1.10.0
(function() {
  var Arity, ProcedureType, Type, TypeBinder, errLib, makeProc, util,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  util = require('./util');

  errLib = require('./error');

  Type = require('./type');

  TypeBinder = require('./type-binder');

  Arity = (function() {
    function Arity(length, isVarArg, defaultVals) {
      var j, len, ref, val;
      this.length = length;
      this.isVarArg = isVarArg;
      this.defaultVals = defaultVals != null ? defaultVals : [];
      this.minLength = 0;
      ref = this.defaultVals;
      for (j = 0, len = ref.length; j < len; j++) {
        val = ref[j];
        if (val !== void 0) {
          this.minLength++;
        }
      }
    }

    Arity.prototype.normalize = function(args) {
      if (args.length === this.length) {
        if (this.isVarArg) {
          return this.normalizeVarArgs(args);
        } else {
          return args;
        }
      } else if (args.length < this.minLength) {
        throw new Error("arity_less_than_minimum: " + this.minLength);
      } else if (args.length > this.length) {
        if (!this.isVarArg) {
          throw new Error("arity_not_vararg");
        } else {
          return this.normalizeVarArgs(args);
        }
      } else {
        return this.normalizeInBetween(args);
      }
    };

    Arity.prototype.normalizeVarArgs = function(args) {
      var i, item, j, len, normalized, rest;
      normalized = [];
      rest = [];
      for (i = j = 0, len = args.length; j < len; i = ++j) {
        item = args[i];
        if (i < this.length - 1) {
          normalized.push(item);
        } else {
          rest.push(item);
        }
      }
      normalized.push(rest);
      return normalized;
    };

    Arity.prototype.normalizeInBetween = function(args) {
      var count, i, item, j, len, normalized, optionalCount, ref;
      normalized = [];
      optionalCount = args.length - this.minLength;
      count = 0;
      ref = this.defaultVals;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        item = ref[i];
        if (i === this.length - 1 && this.isVarArg) {
          if (item === void 0) {
            normalized.push([args[count++]]);
          } else if (optionalCount > 0) {
            normalized.push([args[count++]]);
            optionalCount--;
          } else if (util._isFunction(item)) {
            normalized.push([item()]);
          } else {
            normalized.push([item]);
          }
        } else {
          if (item === void 0) {
            normalized.push(args[count++]);
          } else if (optionalCount > 0) {
            normalized.push(args[count++]);
            optionalCount--;
          } else if (util._isFunction(item)) {
            normalized.push(item());
          } else {
            normalized.push(item);
          }
        }
      }
      return normalized;
    };

    return Arity;

  })();

  ProcedureType = (function(superClass) {
    extend(ProcedureType, superClass);

    function ProcedureType(params, ret, options) {
      var defaultOptions, defaultVal, i, id, j, k, len, len1, param;
      if (options == null) {
        options = {};
      }
      if (!(this instanceof ProcedureType)) {
        return new ProcedureType(params, ret, options);
      }
      ProcedureType.__super__.constructor.call(this, {
        noConvert: true
      });
      id = 0;
      for (i = j = 0, len = params.length; j < len; i = ++j) {
        param = params[i];
        if (!(param instanceof Type)) {
          throw new Error("Procedure:param_" + i + "_not_type: " + param);
        }
      }
      if (!(ret instanceof Type)) {
        throw new Error("Procedure:ret_not_type: " + ret);
      }
      if (options.isVarArg) {
        if (!(params[params.length - 1] instanceof ArrayType)) {
          throw new Error("Procedure:vararg_require_last_param_to_be_array");
        }
      }
      if (options.defaultVals instanceof Array) {
        if (!params.length === options.defaultVals.length) {
          throw new Error("Procedure.default_Vals_not_equal_param_length: " + params.length + " != " + options.defaultVals.length);
        }
        for (i = k = 0, len1 = params.length; k < len1; i = ++k) {
          param = params[i];
          if (options.defaultVals[i] !== void 0) {
            defaultVal = util._isFunction(options.defaultVals[i]) ? options.defaultVals[i]() : options.defaultVals[i];
            if (!param.isa(defaultVal)) {
              throw new Error("Procedure:default_val_" + i + "_not_match_type_" + param);
            }
          }
        }
      }
      defaultOptions = {
        typeID: Type.typeID++,
        parameterTypes: params,
        returnType: ret,
        isVarArg: false
      };
      util._mixin(this, util._extend(defaultOptions, options));
    }

    ProcedureType.prototype.typeCategory = 'ProcedureType';

    ProcedureType.prototype.isGeneric = function() {
      var j, len, param, ref;
      ref = this.parameterTypes;
      for (j = 0, len = ref.length; j < len; j++) {
        param = ref[j];
        if (param.isGeneric()) {
          return true;
        }
      }
      return this.returnType.isGeneric();
    };

    ProcedureType.prototype.isComposite = function() {
      return false;
    };

    ProcedureType.prototype.isPrimitive = function() {
      return false;
    };

    ProcedureType.prototype.isTask = false;

    ProcedureType.prototype.resolve = function(obj, resolver) {
      if (obj.__$t) {
        return obj.__$t;
      } else {
        throw new Error("procedure_type_doesnt_support_resolve");
      }
    };

    ProcedureType.prototype.arity = function() {
      return new Arity(this.parameterTypes.length, this.isVarArg, this.defaultVals);
    };

    ProcedureType.prototype.normalize = function(args) {
      var arity;
      arity = this.arity();
      return arity.normalize(args);
    };

    ProcedureType.prototype.assertArguments = function(args, context) {
      var error, i, j, len, normalized, param, ref;
      if (context == null) {
        context = this.assertArguments;
      }
      normalized = this.normalize(args);
      error = Type.convertError(context);
      ref = this.parameterTypes;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        param = ref[i];
        param._assert(normalized[i], error, "$/" + i);
      }
      if (error.hasErrors()) {
        throw error;
      } else {
        return normalized;
      }
    };

    ProcedureType.prototype.assertResult = function(res, context) {
      if (context == null) {
        context = this.assertResult;
      }
      return this.returnType.assert(res, context);
    };

    ProcedureType.prototype.convertArguments = function(args) {
      var e, errors, i, j, len, normalized, param, ref, result;
      normalized = this.normalize(args);
      errors = [];
      result = [];
      ref = this.parameterTypes;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        param = ref[i];
        result.push(param._convert(normalized[i], errors));
      }
      if (errors.length > 0) {
        e = new Error("invalid_arguments: " + errors);
        e.errors = errors;
        throw e;
      } else {
        return result;
      }
    };

    ProcedureType.prototype.isa = function(obj) {
      if (obj.__$t === this) {
        return true;
      } else {
        return false;
      }
    };

    ProcedureType.prototype.canAssignArgumentsFrom = function(args, resolver) {
      var arg;
      if (resolver == null) {
        resolver = Type;
      }
      return this.canAssignArgumentTypesFrom((function() {
        var j, len, results;
        results = [];
        for (j = 0, len = args.length; j < len; j++) {
          arg = args[j];
          results.push(resolver.resolve(arg));
        }
        return results;
      })());
    };

    ProcedureType.prototype.canAssignArgumentTypesFrom = function(argTypes) {
      var binder, i, j, len, ref, type;
      if (this.parameterTypes.length !== argTypes.length) {
        return false;
      }
      binder = new TypeBinder();
      ref = this.parameterTypes;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        type = ref[i];
        if (!binder.canAssignFrom(type, argTypes[i])) {
          return false;
        }
      }
      return true;
    };

    ProcedureType.prototype.canAssignFrom = function(type) {
      var binder, i, j, len, param, ref;
      if (type instanceof ProcedureType) {
        if (this.parameterTypes.length !== type.parameterTypes.length) {
          return false;
        }
        binder = new TypeBinder();
        ref = this.parameterTypes;
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          param = ref[i];
          if (!binder.canAssignFrom(type.parameterTypes[i], param)) {
            return false;
          }
        }
        return binder.canAssignTo(this.returnType, type.returnType);
      } else {
        return false;
      }
    };

    ProcedureType.prototype.equal = function(type) {
      var i, j, len, param, ref;
      if (type instanceof ProcedureType) {
        if (this.parameterTypes.length !== type.parameterTypes.length) {
          return false;
        }
        ref = this.parameterTypes;
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          param = ref[i];
          if (!param.equal(type.parameterTypes[i])) {
            return false;
          }
        }
        return this.returnType.equal(type.returnType);
      } else {
        return false;
      }
    };

    ProcedureType.prototype._toString = function(env) {
      var param, params;
      params = (function() {
        var j, len, ref, results;
        ref = this.parameterTypes;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          param = ref[j];
          results.push(param._toString(env));
        }
        return results;
      }).call(this);
      return "(" + (params.join(',')) + ") -> " + (this.returnType._toString(env));
    };

    return ProcedureType;

  })(Type);

  makeProc = function(argsTypes, retType, proc, options) {
    var procType;
    if (options == null) {
      options = {};
    }
    procType = ProcedureType(argsTypes, retType, options);
    util._mixin(proc, {
      __$t: procType,
      convert: function() {
        var args, converted, res;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        converted = procType.convertArguments(args);
        res = proc.apply(null, converted);
        if (procType.returnType.isa(res)) {
          return res;
        } else {
          throw new Error("postcondition: " + res + " is not of type " + procType.returnType);
        }
      },
      check: function() {
        var args, asserted;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        asserted = procType.assertArguments(args, proc);
        return procType.assertResult(proc.apply(null, asserted));
      }
    });
    return proc;
  };

  util._mixin(Type, {
    makeProc: makeProc,
    ProcedureType: ProcedureType
  });

  module.exports = ProcedureType;

}).call(this);
