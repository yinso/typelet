// Generated by CoffeeScript 1.10.0
(function() {
  var PropertyType, Type, util,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  util = require('./util');

  Type = require('./type');

  PropertyType = (function(superClass) {
    extend(PropertyType, superClass);

    function PropertyType(name, type, defaultVal) {
      var options, testVal;
      if (!(this instanceof PropertyType)) {
        if (arguments.length === 2) {
          return new PropertyType(name, type);
        } else {
          return new PropertyType(name, type, defaultVal);
        }
      }
      options = {
        typeID: Type.typeID++,
        name: name,
        innerType: type
      };
      if (arguments.length === 3) {
        testVal = util._isFunction(defaultVal) ? defaultVal() : defaultVal;
        if (!type.isa(testVal)) {
          throw new Error("invalid_default_val: " + testVal + " isn't a " + type);
        }
        options.defaultVal = defaultVal;
      }
      util._mixin(this, options);
    }

    PropertyType.prototype.typeCategory = 'Property';

    PropertyType.prototype.isGeneric = function() {
      return this.innerType.isGeneric();
    };

    PropertyType.prototype.isComposite = function() {
      return this.innerType.isComposite();
    };

    PropertyType.prototype.canAssignFrom = function(type) {
      return (type instanceof PropertyType) && this.name === type.name && this.innerType.canAssignFrom(type.innerType);
    };

    PropertyType.prototype.build = PropertyType;

    PropertyType.prototype.isa = function(obj) {
      return this.innerType.isa(obj);
    };

    PropertyType.prototype._convert = function(obj, error, path, isExplicit) {
      return this.innerType._convert(obj, error, path, isExplicit);
    };

    PropertyType.prototype._toString = function(env) {
      return this.name + ":" + (this.innerType._toString(env));
    };

    PropertyType.prototype.equal = function(type) {
      return (type instanceof PropertyType) && this.innerType.equal(type.innerType);
    };

    return PropertyType;

  })(Type);

  util._mixin(Type, {
    makePropertyType: PropertyType
  });

  module.exports = PropertyType;

}).call(this);
