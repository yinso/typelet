// Generated by CoffeeScript 1.10.0
(function() {
  var HashMap, Implmementation, Trait, Type,
    slice = [].slice;

  Type = require('./type');

  HashMap = require('./hashmap');

  Trait = (function() {
    function Trait(name, types1, methods1, typeClass) {
      this.name = name;
      this.types = types1;
      this.methods = methods1 != null ? methods1 : {};
      this.typeClass = typeClass;
      this.implementations = new HashMap();
    }

    Trait.prototype.isGeneric = function() {
      var j, len, ref, type;
      ref = this.types;
      for (j = 0, len = ref.length; j < len; j++) {
        type = ref[j];
        if (type.isGeneric()) {
          return true;
        }
      }
      return false;
    };

    Trait.prototype.isImplement = function() {
      return !this.isGeneric();
    };

    Trait.prototype.implement = function(types, methods) {
      var normalized, trait;
      normalized = types;
      trait = new Trait(this.name, normalized, methods, this.typeClass);
      this.implementations.set(normalized, trait);
      return trait;
    };

    Trait.prototype.merge = function(types) {
      var i, j, len, results, type;
      if (types.length !== this.types.length) {
        throw new Error("types_length_mismatch");
      }
      results = [];
      for (i = j = 0, len = types.length; j < len; i = ++j) {
        type = types[i];
        if (type instanceof Type) {
          results.push(type);
        } else {
          results.push(this.types[i]);
        }
      }
      return results;
    };

    Trait.prototype.run = function() {
      var args, item, op, res, types;
      op = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (args.length !== this.types.length) {
        throw new Error("invalid_argument_count: " + args.length + " != " + this.types.length);
      }
      if (this.isGeneric()) {
        throw new Error("generic_trait_not_implement");
      }
      types = (function() {
        var j, len, results;
        results = [];
        for (j = 0, len = args.length; j < len; j++) {
          item = args[j];
          results.push(this.typeClass.getType(item));
        }
        return results;
      }).call(this);
      res = this.implementations.get(types);
      if (res) {
        return res.run.apply(res, [op].concat(slice.call(args)));
      } else {
        throw new Error("unmatched_arguments: " + args);
      }
    };

    return Trait;

  })();

  Implmementation = (function() {
    function Implmementation(name, type1, methods1) {
      this.name = name;
      this.type = type1;
      this.methods = methods1;
    }

    return Implmementation;

  })();

  module.exports = Trait;

}).call(this);
