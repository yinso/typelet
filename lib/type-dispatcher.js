// Generated by CoffeeScript 1.10.0
(function() {
  var UnaryDispatcher;

  UnaryDispatcher = (function() {
    function UnaryDispatcher(options) {
      if (options == null) {
        options = {};
      }
      if (!(this instanceof UnaryDispatcher)) {
        return new UnaryDispatcher(options);
      }

      /*
      defaultOpts =
        items: {}
        overwrite: false
        onNotExistThrow: true
      util._mixin, @, util._extend defaultOpts, options
       */
      this.items = {};
      this.overwrite = options.overwrite || false;
      this.onNotEixstThrow = (options.onNotExitThrow ? options.onNotExistThrow : true);
    }

    UnaryDispatcher.prototype._genKey = function(type) {
      return type.toString();
    };

    UnaryDispatcher.prototype._get = function(type, notExistThrow) {
      var key;
      if (notExistThrow == null) {
        notExistThrow = this.onNotExistThrow;
      }
      key = this._genKey(type);
      if (this.items.hasOwnProperty(key)) {
        return this.items[key];
      } else if (type.baseType) {
        return this._get(type.baseType);
      } else if (notExistThrow) {
        throw new Error("Dispatcher:get:type_not_found: " + type);
      } else {
        return null;
      }
    };

    UnaryDispatcher.prototype.get = function(types, notExistThrow) {
      var head, res, tail;
      if (notExistThrow == null) {
        notExistThrow = this.onNotExistThrow;
      }
      if (types.length === 0) {
        throw new Error("Dispatcher.get:arity_underflow");
      }
      head = types[0];
      tail = types.slice(1);
      res = this._get(head, false);
      if (res instanceof UnaryDispatcher) {
        if (tail.length === 0) {
          throw new Error("UnaryDispatcher.get:arity_underflow: " + types.length);
        } else {
          return res.get(tail);
        }
      } else if (res) {
        if (tail.length === 0) {
          return res;
        } else {
          throw new Error("UnaryDispatcher.get:arity_overflow: " + types.length);
        }
      } else {
        if (notExistThrow) {
          throw new Error("UnaryDispatcher.get:not_found: " + types);
        } else {
          return void 0;
        }
      }
    };

    UnaryDispatcher.prototype._set = function(type, val) {
      var key;
      key = this._genKey(type);
      if (this.items.hasOwnProperty(key) && !this.overwrite) {
        throw new Error("Dispatcher:set:cannot_overwrite_due_to_setting");
      }
      return this.items[key] = val;
    };

    UnaryDispatcher.prototype.set = function(types, val) {
      var head, innerDispatcher, res, tail;
      if (types.length === 0) {
        throw new Error("Dispatcher:set: no_more_type");
      }
      head = types[0];
      tail = types.slice(1);
      res = this._get(head, false);
      if (res instanceof UnaryDispatcher) {
        if (tail.length === 0) {
          throw new Error("UnaryDispatcher.set:invalid_arity_underflow: " + types.length);
        } else {
          return res.set(tail, val);
        }
      } else if (res) {
        if (tail.length === 0) {
          return this._set(head, val);
        } else {
          throw new Error("UnaryDispatcher.set:invalid_arity_overflow: " + types.length);
        }
      } else {
        if (tail.length === 0) {
          return this._set(head, val);
        } else {
          innerDispatcher = new UnaryDispatcher({
            overwrite: this.overwrite,
            onNotExistThrow: this.onNotExistThrow
          });
          this._set(head, innerDispatcher);
          return innerDispatcher.set(tail, val);
        }
      }
    };

    return UnaryDispatcher;

  })();

  module.exports = UnaryDispatcher;

}).call(this);
