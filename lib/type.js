// Generated by CoffeeScript 1.10.0
(function() {
  var IType, Type,
    slice = [].slice;

  IType = (function() {
    function IType() {}

    IType.prototype.typeID = function() {};

    IType.prototype.signature = function() {};

    IType.prototype.isGeneric = function() {};

    IType.prototype.isComposite = function() {};

    IType.prototype.resolve = function(obj, resolver) {};

    IType.prototype.isSubTypeOf = function(type) {};

    IType.prototype.isAssignableFrom = function(type) {};

    IType.prototype.isa = function(obj) {};

    IType.prototype.convert = function(obj) {};

    IType.prototype.equal = function(type) {};

    return IType;

  })();

  Type = (function() {
    Type.typeID = 0;

    function Type(options) {
      var convert, i, len, ref, ref1, type;
      this.options = options != null ? options : {};
      this.typeID = Type.typeID++;
      this._setupBaseType(this.options.base);
      this._isa = this.options.isa ? this.options.isa : function(x) {
        return true;
      };
      this.converters = [];
      ref = this.options.converters || [];
      for (i = 0, len = ref.length; i < len; i++) {
        ref1 = ref[i], type = ref1[0], convert = ref1[1];
        this.addConverter(type, convert);
      }
    }

    Type.prototype._setupBaseType = function(type) {
      if (this.options.base instanceof Type) {
        return this.baseType = this.options.base;
      }
    };

    Type.prototype._setupConstraint = function(constraint) {
      if (this.options.constraint) {
        return this._constraint = this.options.constraint;
      }
    };

    Type.prototype.addConverter = function(type, converter) {
      if (type instanceof Type && (typeof converter === 'function' || (converter instanceof Function))) {
        return this.converters.push([type, converter]);
      } else {
        throw new Error("invalid_converter: " + type + ", " + converter);
      }
    };

    Type.prototype.isa = function(x) {
      return this._baseIsa(x) && this._isa(x) && this._constraintIsa(x);
    };

    Type.prototype.signature = function() {
      return "@typeID";
    };

    Type.prototype.outerIsa = function(x) {
      return this.isa(x);
    };

    Type.prototype.resolveType = function(x, typeSpace) {
      return this;
    };

    Type.prototype._baseIsa = function(x) {
      if (this.baseType) {
        return this.baseType.isa(x);
      } else {
        return true;
      }
    };

    Type.prototype._constraintIsa = function(x) {
      if (this._constraint) {
        return this._constraint.check(x);
      } else {
        return true;
      }
    };

    Type.prototype.convert = function(x) {
      var converter, e, error, i, len, ref, ref1, type;
      ref = this.converters;
      for (i = 0, len = ref.length; i < len; i++) {
        ref1 = ref[i], type = ref1[0], converter = ref1[1];
        if (type.isa(x)) {
          try {
            return converter(x);
          } catch (error) {
            e = error;
            continue;
          }
        }
      }
      throw new Error("no_matching_converter_type (out of " + this.converters.length + "): " + x);
    };

    Type.prototype.validate = function(x) {
      var e, error;
      try {
        this.convert(x);
        return true;
      } catch (error) {
        e = error;
        return false;
      }
    };

    Type.prototype.isGeneric = function() {
      return false;
    };

    Type.prototype.specialize = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (!this.isGeneric()) {
        throw new Error("type_cannot_specialize:not_generic");
      }
      return this._specialize.apply(this, args);
    };

    Type.prototype.equal = function(type) {
      return false;
    };

    Type.prototype.greater = function(type) {
      return true;
    };

    Type.prototype.contains = function(type) {
      return this.equal(type) || type.inherits(this);
    };

    Type.prototype.inherits = function(type) {
      if (this.baseType) {
        return this.baseType === type || this.baseType.inherits(type);
      } else {
        return false;
      }
    };

    Type.prototype.substituable = function(type) {
      return this.equal(type);
    };

    return Type;

  })();

  module.exports = Type;

}).call(this);
