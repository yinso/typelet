// Generated by CoffeeScript 1.10.0
(function() {
  var AST, Type, TypeEnv, TypeEnvironment, UnaryDispatcher, attachType, convertError, createType, errLib, util,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  util = require('./util');

  errLib = require('./error');

  TypeEnv = require('./type-env');

  UnaryDispatcher = require('./type-dispatcher');

  AST = require('astlet');

  TypeEnvironment = (function(superClass) {
    extend(TypeEnvironment, superClass);

    function TypeEnvironment() {
      return TypeEnvironment.__super__.constructor.apply(this, arguments);
    }

    return TypeEnvironment;

  })(AST.Environment);

  convertError = function(context) {
    if (context == null) {
      context = convertError;
    }
    return new errLib.ConvertError(context);
  };

  Type = (function() {
    Type.typeID = 0;

    function Type(options) {
      if (options == null) {
        options = {
          noConvert: false
        };
      }
      if (!(this instanceof Type)) {
        return new Type();
      }
      if (options.noConvert) {
        this._converter = null;
      } else {
        this._converter = new UnaryDispatcher({
          length: 1
        });
      }
    }

    Type.prototype.signature = function() {};

    Type.prototype.isGeneric = function() {};

    Type.prototype.isAnyType = function() {
      return true;
    };

    Type.prototype.isComposite = function() {};

    Type.prototype.isPrimitive = function() {};

    Type.prototype.resolve = function(obj, resolver) {
      return this;
    };

    Type.prototype.isSubTypeOf = function(type) {};

    Type.prototype.canAssignFrom = function(type) {
      return false;
    };

    Type.prototype.canAssignTo = function(type) {
      return type.canAssignFrom(this);
    };

    Type.prototype.isa = function(obj) {};

    Type.prototype.assert = function(obj, context) {
      if (!this.isa(obj)) {
        throw new errLib.NotTypeOfError(this, obj, context);
      }
      return obj;
    };

    Type.prototype._assert = function(obj, err, path, context) {
      if (path == null) {
        path = '$';
      }
      if (context == null) {
        context = this._assert;
      }
      if (!this.isa(obj)) {
        return err.push(path, new errLib.NotTypeOfError(this, obj, context));
      } else {
        return obj;
      }
    };

    Type.prototype.outerIsa = function(obj) {
      return this.isa(obj);
    };

    Type.prototype.convert = function(obj, options) {
      var context, err, isExplicit, path, ref, res;
      if (options == null) {
        options = {};
      }
      ref = util._extend(options, {
        path: '$',
        isExplicit: true,
        context: this.convert
      }), path = ref.path, isExplicit = ref.isExplicit, context = ref.context;
      err = convertError(context);
      res = this._convert(obj, err, path, isExplicit);
      if (err.hasErrors()) {
        throw err;
      } else {
        return res;
      }
    };

    Type.prototype._convert = function(obj, error, path, isExplicit) {
      var converter, e, error1, type;
      if (this.isa(obj)) {
        return obj;
      }
      if (!this._converter) {
        error.push(path, new errLib.ConversionNotSupportedError(this));
      }
      try {
        type = Type.resolve(obj);
        converter = this._converter.get([type]);
        if (!converter) {
          return error.push(path, new errLib.CannotConvertError(this, obj));
        } else if (converter.isExplicit && !isExplicit) {
          return error.push(path, new errLib.CannotImplicitConvertError(this, obj));
        } else {
          return converter.converter(obj);
        }
      } catch (error1) {
        e = error1;
        return error.push(path, e);
      }
    };

    Type.prototype.setConvert = function(options) {
      var converter, explicit, type;
      if (options == null) {
        options = {};
      }
      type = options.type;
      converter = options.converter;
      explicit = options.explicit || false;
      if (!(type instanceof Type)) {
        throw new Error("Type:setConvert:no_type_specified");
      }
      if (!util._isFunction(converter)) {
        throw new Error("Type.setConvert:no_converter_specified");
      }
      return this._converter.set([type], {
        converter: converter,
        isExplicit: explicit
      });
    };

    Type.prototype.equal = function(type) {};

    Type.prototype.inspect = function() {
      return this.toString();
    };

    Type.prototype.toString = function() {
      return this._toString(new TypeEnv());
    };

    Type.prototype._toString = function(envs) {
      return '<IType>';
    };

    return Type;

  })();

  createType = function(ctor, options) {
    if (!util._isFunction(ctor)) {
      throw new Error("invalid_constructor: " + ctor);
    }
    if (!(ctor.prototype instanceof Type)) {
      util._class({
        constructor: ctor,
        __super__: Type
      });
    }
    return util._new(ctor, options);
  };

  attachType = function(ctor, type) {
    return Object.defineProperty(ctor, '__$t', {
      value: type,
      enumerable: false,
      writable: false,
      configurable: false
    });
  };

  util._mixin(Type, {
    createType: createType,
    attachType: attachType,
    convertError: convertError,
    TypeEnv: TypeEnv,
    baseEnv: new TypeEnvironment(),
    makeDispatcher: UnaryDispatcher
  });

  module.exports = Type;

}).call(this);
