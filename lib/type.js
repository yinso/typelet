// Generated by CoffeeScript 1.10.0
(function() {
  var Arity, ProcedureType, Type, TypeBinder, TypeEnv, UnaryDispatcher, attachType, convertError, createType, errLib, makeProc, util,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  util = require('./util');

  errLib = require('./error');

  TypeEnv = require('./type-env');

  UnaryDispatcher = require('./type-dispatcher');

  convertError = function(context) {
    if (context == null) {
      context = convertError;
    }
    return new errLib.ConvertError(context);
  };

  Type = (function() {
    Type.typeID = 0;

    function Type(options) {
      if (options == null) {
        options = {
          noConvert: false
        };
      }
      if (!(this instanceof Type)) {
        return new Type();
      }
      if (options.noConvert) {
        this._converter = null;
      } else {
        this._converter = new UnaryDispatcher({
          length: 1
        });
      }
    }

    Type.prototype.signature = function() {};

    Type.prototype.isGeneric = function() {};

    Type.prototype.isAnyType = function() {
      return true;
    };

    Type.prototype.isComposite = function() {};

    Type.prototype.isPrimitive = function() {};

    Type.prototype.resolve = function(obj, resolver) {
      return this;
    };

    Type.prototype.isSubTypeOf = function(type) {};

    Type.prototype.canAssignFrom = function(type) {
      return false;
    };

    Type.prototype.canAssignTo = function(type) {
      return type.canAssignFrom(this);
    };

    Type.prototype.isa = function(obj) {};

    Type.prototype.assert = function(obj, context) {
      if (!this.isa(obj)) {
        throw new errLib.NotTypeOfError(this, obj, context);
      }
      return obj;
    };

    Type.prototype._assert = function(obj, err, path, context) {
      if (path == null) {
        path = '$';
      }
      if (context == null) {
        context = this._assert;
      }
      if (!this.isa(obj)) {
        return err.push(path, new errLib.NotTypeOfError(this, obj, context));
      } else {
        return obj;
      }
    };

    Type.prototype.outerIsa = function(obj) {
      return this.isa(obj);
    };

    Type.prototype.convert = function(obj, options) {
      var context, err, isExplicit, path, ref, res;
      if (options == null) {
        options = {};
      }
      ref = util._extend(options, {
        path: '$',
        isExplicit: true,
        context: this.convert
      }), path = ref.path, isExplicit = ref.isExplicit, context = ref.context;
      err = convertError(context);
      res = this._convert(obj, err, path, isExplicit);
      if (err.hasErrors()) {
        throw err;
      } else {
        return res;
      }
    };

    Type.prototype._convert = function(obj, error, path, isExplicit) {
      var converter, e, error1, type;
      if (this.isa(obj)) {
        return obj;
      }
      if (!this._converter) {
        error.push(path, new errLib.ConversionNotSupportedError(this));
      }
      try {
        type = Type.resolve(obj);
        converter = this._converter.get([type]);
        if (!converter) {
          return error.push(path, new errLib.CannotConvertError(this, obj));
        } else if (converter.isExplicit && !isExplicit) {
          return error.push(path, new errLib.CannotImplicitConvertError(this, obj));
        } else {
          return converter.converter(obj);
        }
      } catch (error1) {
        e = error1;
        return error.push(path, e);
      }
    };

    Type.prototype.setConvert = function(options) {
      var converter, explicit, type;
      if (options == null) {
        options = {};
      }
      type = options.type;
      converter = options.converter;
      explicit = options.explicit || false;
      if (!(type instanceof Type)) {
        throw new Error("Type:setConvert:no_type_specified");
      }
      if (!util._isFunction(converter)) {
        throw new Error("Type.setConvert:no_converter_specified");
      }
      return this._converter.set([type], {
        converter: converter,
        isExplicit: explicit
      });
    };

    Type.prototype.equal = function(type) {};

    Type.prototype.inspect = function() {
      return this.toString();
    };

    Type.prototype.toString = function() {
      return this._toString(new TypeEnv());
    };

    Type.prototype._toString = function(envs) {
      return '<IType>';
    };

    return Type;

  })();

  createType = function(ctor, options) {
    if (!util._isFunction(ctor)) {
      throw new Error("invalid_constructor: " + ctor);
    }
    if (!(ctor.prototype instanceof Type)) {
      util._class({
        constructor: ctor,
        __super__: Type
      });
    }
    return util._new(ctor, options);
  };

  attachType = function(ctor, type) {
    return Object.defineProperty(ctor, '__$t', {
      value: type,
      enumerable: false,
      writable: false,
      configurable: false
    });
  };

  util._mixin(Type, {
    createType: createType,
    attachType: attachType,
    convertError: convertError,
    TypeEnv: TypeEnv
  });

  Arity = (function() {
    function Arity(length, isVarArg, defaultVals) {
      var j, len, ref, val;
      this.length = length;
      this.isVarArg = isVarArg;
      this.defaultVals = defaultVals != null ? defaultVals : [];
      this.minLength = 0;
      ref = this.defaultVals;
      for (j = 0, len = ref.length; j < len; j++) {
        val = ref[j];
        if (val !== void 0) {
          this.minLength++;
        }
      }
    }

    Arity.prototype.normalize = function(args) {
      if (args.length === this.length) {
        if (this.isVarArg) {
          return this.normalizeVarArgs(args);
        } else {
          return args;
        }
      } else if (args.length < this.minLength) {
        throw new Error("arity_less_than_minimum: " + this.minLength);
      } else if (args.length > this.length) {
        if (!this.isVarArg) {
          throw new Error("arity_not_vararg");
        } else {
          return this.normalizeVarArgs(args);
        }
      } else {
        return this.normalizeInBetween(args);
      }
    };

    Arity.prototype.normalizeVarArgs = function(args) {
      var i, item, j, len, normalized, rest;
      normalized = [];
      rest = [];
      for (i = j = 0, len = args.length; j < len; i = ++j) {
        item = args[i];
        if (i < this.length - 1) {
          normalized.push(item);
        } else {
          rest.push(item);
        }
      }
      normalized.push(rest);
      return normalized;
    };

    Arity.prototype.normalizeInBetween = function(args) {
      var count, i, item, j, len, normalized, optionalCount, ref;
      normalized = [];
      optionalCount = args.length - this.minLength;
      count = 0;
      ref = this.defaultVals;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        item = ref[i];
        if (i === this.length - 1 && this.isVarArg) {
          if (item === void 0) {
            normalized.push([args[count++]]);
          } else if (optionalCount > 0) {
            normalized.push([args[count++]]);
            optionalCount--;
          } else if (util._isFunction(item)) {
            normalized.push([item()]);
          } else {
            normalized.push([item]);
          }
        } else {
          if (item === void 0) {
            normalized.push(args[count++]);
          } else if (optionalCount > 0) {
            normalized.push(args[count++]);
            optionalCount--;
          } else if (util._isFunction(item)) {
            normalized.push(item());
          } else {
            normalized.push(item);
          }
        }
      }
      return normalized;
    };

    return Arity;

  })();

  TypeBinder = require('./type-binder');

  ProcedureType = (function(superClass) {
    extend(ProcedureType, superClass);

    function ProcedureType(params, ret, options) {
      var defaultOptions, defaultVal, i, id, j, k, len, len1, param;
      if (options == null) {
        options = {};
      }
      if (!(this instanceof ProcedureType)) {
        return new ProcedureType(params, ret, options);
      }
      ProcedureType.__super__.constructor.call(this, {
        noConvert: true
      });
      id = 0;
      for (i = j = 0, len = params.length; j < len; i = ++j) {
        param = params[i];
        if (!(param instanceof Type)) {
          throw new Error("Procedure:param_" + i + "_not_type: " + param);
        }
      }
      if (!(ret instanceof Type)) {
        throw new Error("Procedure:ret_not_type: " + ret);
      }
      if (options.isVarArg) {
        if (!(params[params.length - 1] instanceof ArrayType)) {
          throw new Error("Procedure:vararg_require_last_param_to_be_array");
        }
      }
      if (options.defaultVals instanceof Array) {
        if (!params.length === options.defaultVals.length) {
          throw new Error("Procedure.default_Vals_not_equal_param_length: " + params.length + " != " + options.defaultVals.length);
        }
        for (i = k = 0, len1 = params.length; k < len1; i = ++k) {
          param = params[i];
          if (options.defaultVals[i] !== void 0) {
            defaultVal = util._isFunction(options.defaultVals[i]) ? options.defaultVals[i]() : options.defaultVals[i];
            if (!param.isa(defaultVal)) {
              throw new Error("Procedure:default_val_" + i + "_not_match_type_" + param);
            }
          }
        }
      }
      defaultOptions = {
        typeID: Type.typeID++,
        parameterTypes: params,
        returnType: ret,
        isVarArg: false
      };
      util._mixin(this, util._extend(defaultOptions, options));
    }

    ProcedureType.prototype.typeCategory = 'ProcedureType';

    ProcedureType.prototype.isGeneric = function() {
      var j, len, param, ref;
      ref = this.parameterTypes;
      for (j = 0, len = ref.length; j < len; j++) {
        param = ref[j];
        if (param.isGeneric()) {
          return true;
        }
      }
      return this.returnType.isGeneric();
    };

    ProcedureType.prototype.isComposite = function() {
      return false;
    };

    ProcedureType.prototype.isPrimitive = function() {
      return false;
    };

    ProcedureType.prototype.isTask = false;

    ProcedureType.prototype.resolve = function(obj, resolver) {
      if (obj.__$t) {
        return obj.__$t;
      } else {
        throw new Error("procedure_type_doesnt_support_resolve");
      }
    };

    ProcedureType.prototype.arity = function() {
      return new Arity(this.parameterTypes.length, this.isVarArg, this.defaultVals);
    };

    ProcedureType.prototype.normalize = function(args) {
      var arity;
      arity = this.arity();
      return arity.normalize(args);
    };

    ProcedureType.prototype.assertArguments = function(args, context) {
      var error, i, j, len, normalized, param, ref;
      if (context == null) {
        context = this.assertArguments;
      }
      normalized = this.normalize(args);
      error = convertError(context);
      ref = this.parameterTypes;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        param = ref[i];
        param._assert(normalized[i], error, "$/" + i);
      }
      if (error.hasErrors()) {
        throw error;
      } else {
        return normalized;
      }
    };

    ProcedureType.prototype.assertResult = function(res, context) {
      if (context == null) {
        context = this.assertResult;
      }
      return this.returnType.assert(res, context);
    };

    ProcedureType.prototype.convertArguments = function(args) {
      var e, errors, i, j, len, normalized, param, ref, result;
      normalized = this.normalize(args);
      errors = [];
      result = [];
      ref = this.parameterTypes;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        param = ref[i];
        result.push(param._convert(normalized[i], errors));
      }
      if (errors.length > 0) {
        e = new Error("invalid_arguments: " + errors);
        e.errors = errors;
        throw e;
      } else {
        return result;
      }
    };

    ProcedureType.prototype.isa = function(obj) {
      if (obj.__$t === this) {
        return true;
      } else {
        return false;
      }
    };

    ProcedureType.prototype.canAssignArgumentsFrom = function(args, resolver) {
      var arg;
      if (resolver == null) {
        resolver = Type;
      }
      return this.canAssignArgumentTypesFrom((function() {
        var j, len, results;
        results = [];
        for (j = 0, len = args.length; j < len; j++) {
          arg = args[j];
          results.push(resolver.resolve(arg));
        }
        return results;
      })());
    };

    ProcedureType.prototype.canAssignArgumentTypesFrom = function(argTypes) {
      var binder, i, j, len, ref, type;
      if (this.parameterTypes.length !== argTypes.length) {
        return false;
      }
      binder = new TypeBinder();
      ref = this.parameterTypes;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        type = ref[i];
        if (!binder.canAssignFrom(type, argTypes[i])) {
          return false;
        }
      }
      return true;
    };

    ProcedureType.prototype.canAssignFrom = function(type) {
      var binder, i, j, len, param, ref;
      if (type instanceof ProcedureType) {
        if (this.parameterTypes.length !== type.parameterTypes.length) {
          return false;
        }
        binder = new TypeBinder();
        ref = this.parameterTypes;
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          param = ref[i];
          if (!binder.canAssignFrom(type.parameterTypes[i], param)) {
            return false;
          }
        }
        return binder.canAssignTo(this.returnType, type.returnType);
      } else {
        return false;
      }
    };

    ProcedureType.prototype._toString = function(env) {
      var param, params;
      params = (function() {
        var j, len, ref, results;
        ref = this.parameterTypes;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          param = ref[j];
          results.push(param._toString(env));
        }
        return results;
      }).call(this);
      return "(" + (params.join(',')) + ") -> " + (this.returnType._toString(env));
    };

    return ProcedureType;

  })(Type);

  makeProc = function(argsTypes, retType, proc, options) {
    var procType;
    if (options == null) {
      options = {};
    }
    procType = ProcedureType(argsTypes, retType, options);
    util._mixin(proc, {
      __$t: procType,
      convert: function() {
        var args, converted, res;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        converted = procType.convertArguments(args);
        res = proc.apply(null, converted);
        if (procType.returnType.isa(res)) {
          return res;
        } else {
          throw new Error("postcondition: " + res + " is not of type " + procType.returnType);
        }
      },
      check: function() {
        var args, asserted;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        asserted = procType.assertArguments(args, proc);
        return procType.assertResult(proc.apply(null, asserted));
      }
    });
    return proc;
  };

  util._mixin(Type, {
    createType: createType,
    attachType: attachType,
    convertError: convertError,
    TypeEnv: TypeEnv,
    makeProc: makeProc,
    makeDispatcher: UnaryDispatcher,
    makeProcedureType: ProcedureType
  });

  module.exports = Type;

}).call(this);
