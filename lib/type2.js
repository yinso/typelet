// Generated by CoffeeScript 1.10.0
(function() {
  var AnyType, Arity, ArrayType, BooleanType, DateType, FloatType, IntegerType, NullType, ObjectType, OneOfType, PrimitiveType, ProcedureType, PropertyType, RegExpType, StringType, Type, TypeEnv, UnaryDispatcher, UnitType, _class, _extend, _inherits, _isFunction, _mixin, _new, _props, attachType, createType, makeProc, typeID,
    slice = [].slice,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  typeID = 0;

  _extend = function() {
    var j, key, len, obj, objs, res, val;
    objs = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    res = {};
    for (j = 0, len = objs.length; j < len; j++) {
      obj = objs[j];
      for (key in obj) {
        val = obj[key];
        if (obj.hasOwnProperty(key)) {
          res[key] = val;
        }
      }
    }
    return res;
  };

  _props = function(obj, config) {
    var key, res, val;
    if (config == null) {
      config = {};
    }
    res = {};
    for (key in obj) {
      val = obj[key];
      if (obj.hasOwnProperty(key)) {
        res[key] = {
          value: val,
          writable: (config.writable instanceof Array) && indexOf.call(config.writable, key) >= 0,
          configurable: (config.configurable instanceof Array) && indexOf.call(config.configurable, key) >= 0,
          enumerable: (config.enumerable instanceof Array) && indexOf.call(config.enumerable, key) >= 0
        };
      }
    }
    return res;
  };

  _mixin = function(obj, options) {
    return Object.defineProperties(obj, _props(options));
  };

  _isFunction = function(func) {
    return typeof func === 'function' || func instanceof Function;
  };

  _class = function(options) {
    var ctor, parent;
    if (options == null) {
      options = {};
    }
    ctor = options.hasOwnProperty('constructor') && _isFunction(options.constructor) ? options.constructor : function() {};
    parent = _isFunction(options.__super__) ? options.__super__ : Object;
    ctor.prototype = _new(parent, _extend({
      constructor: ctor
    }, options));
    _mixin(ctor, {
      __super__: parent
    });
    return ctor;
  };

  _new = function(ctor, options, configs) {
    if (!_isFunction(ctor)) {
      throw new Error("_new_requires_ctor_to_be_function");
    }
    return Object.create(ctor.prototype, _props(options, configs));
  };

  _inherits = function(_class, _ancestor) {
    if (!(_isFunction((function() {
      function _Class() {}

      return _Class;

    })()) && _isFunction(_ancestor))) {
      throw new Error("inherit_expects_functions");
    }
    return _class.prototype instanceof _ancestor;
  };

  TypeEnv = (function() {
    function TypeEnv(prev) {
      this.prev = prev != null ? prev : null;
      this.inner = {};
      this.id = 0;
    }

    TypeEnv.prototype.push = function(type, key) {
      var k, ref, val;
      if (key == null) {
        key = void 0;
      }
      if (key) {
        if (this.inner.hasOwnProperty(key)) {
          throw new Error("duplicate_key: " + key);
        } else {
          this.inner[key] = type;
          return key;
        }
      } else {
        ref = this.inner;
        for (k in ref) {
          val = ref[k];
          if (val === type) {
            return k;
          }
        }
        key = this.id++;
        this.inner[key] = type;
        return key;
      }
    };

    TypeEnv.prototype.getKey = function(type) {
      var key, ref, val;
      ref = this.inner;
      for (key in ref) {
        val = ref[key];
        if (val === type) {
          return key;
        }
      }
      throw new Error("unknown_type: " + type);
    };

    TypeEnv.prototype.print = function(type) {
      var key;
      if (type.typeCategory !== 'TypeVar') {
        return type.toString();
      } else {
        key = this.push(type);
        return "T_" + key;
      }
    };

    return TypeEnv;

  })();

  UnaryDispatcher = (function() {
    function UnaryDispatcher(options) {
      if (options == null) {
        options = {};
      }
      if (!(this instanceof UnaryDispatcher)) {
        return new UnaryDispatcher(options);
      }

      /*
      defaultOpts =
        items: {}
        overwrite: false
        onNotExistThrow: true
      _mixin, @, _extend defaultOpts, options
       */
      this.items = {};
      this.overwrite = options.overwrite || false;
      this.onNotEixstThrow = (options.onNotExitThrow ? options.onNotExistThrow : true);
    }

    UnaryDispatcher.prototype._genKey = function(type) {
      return type.toString();
    };

    UnaryDispatcher.prototype._get = function(type, notExistThrow) {
      var key;
      if (notExistThrow == null) {
        notExistThrow = this.onNotExistThrow;
      }
      key = this._genKey(type);
      if (this.items.hasOwnProperty(key)) {
        return this.items[key];
      } else if (type.baseType instanceof Type) {
        return this._get(type.baseType);
      } else if (notExistThrow) {
        throw new Error("Dispatcher:get:type_not_found: " + type);
      } else {
        return null;
      }
    };

    UnaryDispatcher.prototype.get = function(types, notExistThrow) {
      var head, res, tail;
      if (notExistThrow == null) {
        notExistThrow = this.onNotExistThrow;
      }
      if (types.length === 0) {
        throw new Error("Dispatcher.get:arity_underflow");
      }
      head = types[0];
      tail = types.slice(1);
      res = this._get(head, false);
      if (res instanceof UnaryDispatcher) {
        if (tail.length === 0) {
          throw new Error("UnaryDispatcher.get:arity_underflow: " + types.length);
        } else {
          return res.get(tail);
        }
      } else if (res) {
        if (tail.length === 0) {
          return res;
        } else {
          throw new Error("UnaryDispatcher.get:arity_overflow: " + types.length);
        }
      } else {
        if (notExistThrow) {
          throw new Error("UnaryDispatcher.get:not_found: " + types);
        } else {
          return void 0;
        }
      }
    };

    UnaryDispatcher.prototype._set = function(type, val) {
      var key;
      key = this._genKey(type);
      if (this.items.hasOwnProperty(key) && !this.overwrite) {
        throw new Error("Dispatcher:set:cannot_overwrite_due_to_setting");
      }
      return this.items[key] = val;
    };

    UnaryDispatcher.prototype.set = function(types, val) {
      var head, innerDispatcher, res, tail;
      if (types.length === 0) {
        throw new Error("Dispatcher:set: no_more_type");
      }
      head = types[0];
      tail = types.slice(1);
      res = this._get(head, false);
      if (res instanceof UnaryDispatcher) {
        if (tail.length === 0) {
          throw new Error("UnaryDispatcher.set:invalid_arity_underflow: " + types.length);
        } else {
          return res.set(tail, val);
        }
      } else if (res) {
        if (tail.length === 0) {
          return this._set(head, val);
        } else {
          throw new Error("UnaryDispatcher.set:invalid_arity_overflow: " + types.length);
        }
      } else {
        if (tail.length === 0) {
          return this._set(head, val);
        } else {
          innerDispatcher = new UnaryDispatcher({
            overwrite: this.overwrite,
            onNotExistThrow: this.onNotExistThrow
          });
          this._set(head, innerDispatcher);
          return innerDispatcher.set(tail, val);
        }
      }
    };

    return UnaryDispatcher;

  })();

  Type = (function() {
    function Type(options) {
      if (options == null) {
        options = {
          noConvert: false
        };
      }
      if (!(this instanceof Type)) {
        return new Type();
      }
      if (options.noConvert) {
        this._converter = null;
      } else {
        this._converter = new UnaryDispatcher({
          length: 1
        });
      }
    }

    Type.prototype.signature = function() {};

    Type.prototype.isGeneric = function() {};

    Type.prototype.isAnyType = function() {
      return true;
    };

    Type.prototype.isComposite = function() {};

    Type.prototype.isPrimitive = function() {};

    Type.prototype.resolve = function(obj, resolver) {
      return this;
    };

    Type.prototype.isSubTypeOf = function(type) {};

    Type.prototype.isAssignableFrom = function(type) {};

    Type.prototype.isa = function(obj) {};

    Type.prototype.outerIsa = function(obj) {
      return this.isa(obj);
    };

    Type.prototype.convert = function(obj) {
      var err, errors, res;
      errors = [];
      res = this._convert(obj, errors);
      if (errors.length > 0) {
        err = new Error();
        err.errors = errors;
        throw err;
      } else {
        return res;
      }
    };

    Type.prototype._convert = function(obj, errors) {
      var converter, e, error, type;
      if (this.isa(obj)) {
        return obj;
      }
      if (!this._converter) {
        errors.push(new Error("Type:no_conversion_allowed: " + this));
      }
      try {
        type = Type.resolve(obj);
        converter = this._converter.get([type]);
        return converter(obj);
      } catch (error) {
        e = error;
        return errors.push(e);
      }
    };

    Type.prototype.addConverter = function(type, converter) {
      return this._converter.set([type], converter);
    };

    Type.prototype.equal = function(type) {};

    Type.prototype.inspect = function() {
      return this.toString();
    };

    Type.prototype.toString = function() {
      return this._toString(new TypeEnv());
    };

    Type.prototype._toString = function(envs) {
      return '<IType>';
    };

    return Type;

  })();

  createType = function(ctor, options) {
    if (!_isFunction(ctor)) {
      throw new Error("invalid_constructor: " + ctor);
    }
    if (!(ctor.prototype instanceof Type)) {
      _class({
        constructor: ctor,
        __super__: Type
      });
    }
    return _new(ctor, options);
  };

  attachType = function(ctor, type) {
    return Object.defineProperty(ctor, '__$t', {
      value: type,
      enumerable: false,
      writable: false,
      configurable: false
    });
  };

  PrimitiveType = (function(superClass) {
    extend(PrimitiveType, superClass);

    function PrimitiveType(name, options) {
      if (options == null) {
        options = {};
      }
      if (!(this instanceof PrimitiveType)) {
        return new PrimitiveType(name, options);
      }
      PrimitiveType.__super__.constructor.call(this);
      _mixin(this, _extend({
        name: name,
        typeID: typeID++
      }, options));
      if (_isFunction(options["instanceof"])) {
        attachType(options["instanceof"], this);
      }
    }

    PrimitiveType.prototype.signature = function() {
      return "1:" + this.typeID;
    };

    PrimitiveType.prototype.typeCategory = 'Primitive';

    PrimitiveType.prototype.isPrimitive = function() {
      return false;
    };

    PrimitiveType.prototype.isComposite = function() {
      return false;
    };

    PrimitiveType.prototype.isGeneric = function() {
      return false;
    };

    PrimitiveType.prototype.isSubTypeOf = function(type) {
      return false;
    };

    PrimitiveType.prototype.isAssignableFrom = function(type) {
      if (type === this) {
        return true;
      } else {
        return false;
      }
    };

    PrimitiveType.prototype.isa = function(obj) {
      return typeof obj === this.name.toLowerCase();
    };

    PrimitiveType.prototype.equal = function(type) {
      return type === this;
    };

    PrimitiveType.prototype._toString = function(env) {
      return this.name;
    };

    return PrimitiveType;

  })(Type);

  UnitType = Type.Unit = PrimitiveType('Unit', {
    isa: function(obj) {
      return obj === void 0;
    }
  });

  NullType = Type.Null = PrimitiveType('Null', {
    isa: function(obj) {
      return obj === null;
    }
  });

  BooleanType = Type.Boolean = PrimitiveType('Boolean', {
    "instanceof": Boolean
  });

  IntegerType = Type.Integer = PrimitiveType('Integer', {
    isa: function(obj) {
      return typeof obj === 'number' && Math.floor(obj) === obj;
    }
  });

  FloatType = Type.Float = PrimitiveType('Float', {
    isa: function(obj) {
      return typeof obj === 'number';
    },
    "instanceof": Number
  });

  StringType = Type.String = PrimitiveType('String', {
    "instanceof": String
  });

  DateType = Type.Date = PrimitiveType('Date', {
    isa: function(obj) {
      return obj instanceof Date;
    },
    "instanceof": Date
  });

  RegExpType = Type.RegExp = PrimitiveType('RegExp', {
    isa: function(obj) {
      return obj instanceof RegExp;
    },
    "instanceof": RegExp
  });

  IntegerType.addConverter(StringType, function(s) {
    var res;
    res = parseInt(s);
    if (res.toString() === s) {
      return res;
    } else {
      throw new Error("invalid_integer: " + s);
    }
  });

  IntegerType.addConverter(FloatType, function(f) {
    return Math.floor(f);
  });

  FloatType.addConverter(StringType, function(s) {
    var res;
    res = parseFloat(s);
    if (res.toString() === s) {
      return res;
    } else {
      throw new Error("invalid_float: " + s);
    }
  });

  FloatType.addConverter(IntegerType, function(i) {
    return i;
  });

  DateType.addConverter(StringType, function(s) {
    return new Date(s);
  });

  DateType.addConverter(IntegerType, function(i) {
    return new Date(i);
  });

  StringType.addConverter(IntegerType, function(i) {
    return i.toString();
  });

  StringType.addConverter(FloatType, function(f) {
    return f.toString();
  });

  StringType.addConverter(DateType, function(d) {
    return d.toISOString();
  });

  StringType.addConverter(BooleanType, function(b) {
    return b.toString();
  });

  AnyType = (function(superClass) {
    extend(AnyType, superClass);

    function AnyType() {
      if (!(this instanceof AnyType)) {
        return new AnyType();
      }
      AnyType.__super__.constructor.call(this);
      _mixin(this, {
        typeID: typeID++
      });
    }

    AnyType.prototype.typeCategory = 'TypeVar';

    AnyType.prototype.signature = function() {
      return "0";
    };

    AnyType.prototype.isGeneric = function() {
      return true;
    };

    AnyType.prototype.isComposite = function() {
      return false;
    };

    AnyType.prototype.isPrimitive = function() {
      return false;
    };

    AnyType.prototype._toString = function(env) {
      return env.print(this);
    };

    AnyType.prototype.equal = function(type) {
      return type instanceof AnyType;
    };

    AnyType.prototype.isa = function(obj) {
      return true;
    };

    return AnyType;

  })(Type);

  ArrayType = (function(superClass) {
    extend(ArrayType, superClass);

    function ArrayType(innerType) {
      if (innerType == null) {
        innerType = AnyType();
      }
      if (!(this instanceof ArrayType)) {
        return new ArrayType(innerType);
      }
      ArrayType.__super__.constructor.call(this);
      _mixin(this, {
        typeID: typeID++,
        innerType: innerType
      });
    }

    ArrayType.prototype.typeCategory = 'Array';

    ArrayType.prototype.signature = function() {};

    ArrayType.prototype.isGeneric = function() {
      return this.innerType.isGeneric();
    };

    ArrayType.prototype.isComposite = function() {
      return true;
    };

    ArrayType.prototype.build = ArrayType;

    ArrayType.prototype.isa = function(obj) {
      var item, j, len;
      if (obj instanceof Array) {
        for (j = 0, len = obj.length; j < len; j++) {
          item = obj[j];
          if (!this.innerType.isa(item)) {
            return false;
          }
        }
        return true;
      } else {
        return false;
      }
    };

    ArrayType.prototype.outerIsa = function(obj) {
      return obj instanceof Array;
    };

    ArrayType.prototype.resolve = function(obj, resolver) {
      var current, i, item, j, len, type;
      current = null;
      if (obj.length === 0) {
        throw new Error("unable_to_resolve_array_type");
      }
      for (i = j = 0, len = obj.length; j < len; i = ++j) {
        item = obj[i];
        type = resolver.resolve(item);
        if (i === 0) {
          current = type;
        } else if (current.isAssignableFrom(type)) {
          continue;
        } else if (type.isAssignableFrom(current)) {
          current = type;
        } else {
          throw new Error("array_type_resolve:inner_types_incompatible: " + current + " <> " + type);
        }
      }
      return ArrayType(current);
    };

    ArrayType.prototype.equal = function(type) {
      return (type instanceof ArrayType) && this.innerType.equal(type.innerType);
    };

    ArrayType.prototype._toString = function(env) {
      return "Array<" + (env.print(this.innerType)) + ">";
    };

    return ArrayType;

  })(Type);

  attachType(Array, ArrayType());

  PropertyType = (function(superClass) {
    extend(PropertyType, superClass);

    function PropertyType(name, type, defaultVal) {
      var options, testVal;
      if (!(this instanceof PropertyType)) {
        if (arguments.length === 2) {
          return new PropertyType(name, type);
        } else {
          return new PropertyType(name, type, defaultVal);
        }
      }
      options = {
        typeID: typeID++,
        name: name,
        innerType: type
      };
      if (arguments.length === 3) {
        testVal = _isFunction(defaultVal) ? defaultVal() : defaultVal;
        if (!type.isa(testVal)) {
          throw new Error("invalid_default_val: " + testVal + " isn't a " + type);
        }
        options.defaultVal = defaultVal;
      }
      _mixin(this, options);
    }

    PropertyType.prototype.typeCategory = 'Property';

    PropertyType.prototype.isGeneric = function() {
      return this.innerType.isGeneric();
    };

    PropertyType.prototype.isComposite = function() {
      return this.innerType.isComposite();
    };

    PropertyType.prototype.build = PropertyType;

    PropertyType.prototype.isa = function(obj) {
      return this.innerType.isa(obj);
    };

    PropertyType.prototype._convert = function(obj, errors) {
      return this.innerType._convert(obj, errors);
    };

    PropertyType.prototype._toString = function(env) {
      return this.name + ":" + (this.innerType._toString(env));
    };

    PropertyType.prototype.equal = function(type) {
      return (type instanceof PropertyType) && this.innerType.equal(type.innerType);
    };

    return PropertyType;

  })(Type);

  ObjectType = (function(superClass) {
    extend(ObjectType, superClass);

    function ObjectType(properties) {
      var j, len, options, prop;
      if (properties == null) {
        properties = [];
      }
      if (!(this instanceof ObjectType)) {
        return new ObjectType(properties);
      }
      ObjectType.__super__.constructor.call(this);
      for (j = 0, len = properties.length; j < len; j++) {
        prop = properties[j];
        if (!(prop instanceof Type) && prop.typeCategory === 'Property') {
          throw new Error("invalid_property_type: " + prop);
        }
      }
      options = {
        typeID: typeID++,
        properties: properties
      };
      _mixin(this, options);
    }

    ObjectType.prototype.typeCategory = 'Object';

    ObjectType.prototype.isGeneric = function() {
      var j, len, prop, ref;
      ref = this.properties;
      for (j = 0, len = ref.length; j < len; j++) {
        prop = ref[j];
        if (prop.isGeneric()) {
          return true;
        }
      }
      return false;
    };

    ObjectType.prototype.isComposite = function() {
      return true;
    };

    ObjectType.prototype.build = ObjectType;

    ObjectType.prototype.isa = function(obj) {
      var j, len, prop, ref;
      if (this.outerIsa(obj)) {
        ref = this.properties;
        for (j = 0, len = ref.length; j < len; j++) {
          prop = ref[j];
          if (!prop.isa(obj[key])) {
            return false;
          }
        }
        return true;
      } else {
        return false;
      }
    };

    ObjectType.prototype.outerIsa = function(obj) {
      return obj instanceof Object;
    };

    ObjectType.prototype.resolve = function(obj, resolver) {
      var key, props, val;
      props = (function() {
        var results;
        results = [];
        for (key in obj) {
          val = obj[key];
          results.push(PropertyType(key, resolver.resolve(val)));
        }
        return results;
      })();
      return ObjectType(props);
    };

    ObjectType.prototype._sortedProperties = function() {
      return [].concat(this.properties).sort(function(a, b) {
        return a.name > b.name;
      });
    };

    ObjectType.prototype.equal = function(type) {
      var i, j, len, prop, sortedA, sortedB;
      if (type instanceof ObjectType) {
        if (this.properties.length !== type.properties.length) {
          return false;
        }
        sortedA = this._sortedProperties();
        sortedB = type._sortedProperties();
        for (i = j = 0, len = sortedA.length; j < len; i = ++j) {
          prop = sortedA[i];
          if (!prop.equal(sortedB[i])) {
            return false;
          }
        }
        return true;
      } else {
        return false;
      }
    };

    ObjectType.prototype._toString = function(env) {
      var prop, props;
      props = (function() {
        var j, len, ref, results;
        ref = this.properties;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          prop = ref[j];
          results.push(prop._toString(env));
        }
        return results;
      }).call(this);
      return "Object[" + (props.join(',')) + "]";
    };

    return ObjectType;

  })(Type);

  attachType(Object, ObjectType());

  OneOfType = (function(superClass) {
    extend(OneOfType, superClass);

    function OneOfType() {
      var j, len, type, types;
      types = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (!(this instanceof OneOfType)) {
        return (function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor, result = func.apply(child, args);
          return Object(result) === result ? result : child;
        })(OneOfType, types, function(){});
      }
      OneOfType.__super__.constructor.call(this);
      for (j = 0, len = types.length; j < len; j++) {
        type = types[j];
        if (!type instanceof Type) {
          throw new Error("one_of_type_take_only_types: " + type);
        }
      }
      _mixin(this, {
        typeID: typeID++,
        innerTypes: types
      });
    }

    OneOfType.prototype.category = 'OneOfType';

    OneOfType.prototype.sortedTypes = function() {
      return [].concat(this.innerTypes).sort(function(a, b) {
        return a.typeID < b.typeID;
      });
    };

    OneOfType.prototype.isa = function(obj) {
      var j, len, ref, type;
      ref = this.innerTypes;
      for (j = 0, len = ref.length; j < len; j++) {
        type = ref[j];
        if (type.isa(obj)) {
          return true;
        }
      }
      return false;
    };

    OneOfType.prototype.equal = function(type) {
      var i, j, len, sortedA, sortedB;
      if (type instanceof OneOfType) {
        if (this.innerTypes.length !== type.innerTypes.length) {
          return false;
        }
        sortedA = this.sortedTypes();
        sortedB = type.sortedTypes();
        for (i = j = 0, len = sortedA.length; j < len; i = ++j) {
          type = sortedA[i];
          if (!type.equal(sortedB[i])) {
            return false;
          }
        }
        return true;
      } else {
        return false;
      }
    };

    OneOfType.prototype.resolve = function(obj, resolver) {
      var e, error, j, len, ref, type;
      ref = this.innerTypes;
      for (j = 0, len = ref.length; j < len; j++) {
        type = ref[j];
        try {
          return type.resolve(obj, resolver);
        } catch (error) {
          e = error;
          continue;
        }
      }
      throw new Error("unknown_type: " + obj);
    };

    OneOfType.prototype._toString = function(env) {
      var type, types;
      types = (function() {
        var j, len, ref, results;
        ref = this.innerTypes;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          type = ref[j];
          results.push(type._toString(env));
        }
        return results;
      }).call(this);
      return "OneOf[" + (types.join(',')) + "]";
    };

    return OneOfType;

  })(Type);

  Arity = (function() {
    function Arity(length, isVarArg, defaultVals) {
      var j, len, ref, val;
      this.length = length;
      this.isVarArg = isVarArg;
      this.defaultVals = defaultVals != null ? defaultVals : [];
      this.minLength = 0;
      ref = this.defaultVals;
      for (j = 0, len = ref.length; j < len; j++) {
        val = ref[j];
        if (val !== void 0) {
          this.minLength++;
        }
      }
    }

    Arity.prototype.normalize = function(args) {
      if (args.length === this.length) {
        if (this.isVarArg) {
          return this.normalizeVarArgs(args);
        } else {
          return args;
        }
      } else if (args.length < this.minLength) {
        throw new Error("arity_less_than_minimum: " + this.minLength);
      } else if (args.length > this.length) {
        if (!this.isVarArg) {
          throw new Error("arity_not_vararg");
        } else {
          return this.normalizeVarArgs(args);
        }
      } else {
        return this.normalizeInBetween(args);
      }
    };

    Arity.prototype.normalizeVarArgs = function(args) {
      var i, item, j, len, normalized, rest;
      normalized = [];
      rest = [];
      for (i = j = 0, len = args.length; j < len; i = ++j) {
        item = args[i];
        if (i < this.length - 1) {
          normalized.push(item);
        } else {
          rest.push(item);
        }
      }
      normalized.push(rest);
      return normalized;
    };

    Arity.prototype.normalizeInBetween = function(args) {
      var count, i, item, j, len, normalized, optionalCount, ref;
      normalized = [];
      optionalCount = args.length - this.minLength;
      count = 0;
      ref = this.defaultVals;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        item = ref[i];
        if (i === this.length - 1 && this.isVarArg) {
          if (item === void 0) {
            normalized.push([args[count++]]);
          } else if (optionalCount > 0) {
            normalized.push([args[count++]]);
            optionalCount--;
          } else if (_isFunction(item)) {
            normalized.push([item()]);
          } else {
            normalized.push([item]);
          }
        } else {
          if (item === void 0) {
            normalized.push(args[count++]);
          } else if (optionalCount > 0) {
            normalized.push(args[count++]);
            optionalCount--;
          } else if (_isFunction(item)) {
            normalized.push(item());
          } else {
            normalized.push(item);
          }
        }
      }
      return normalized;
    };

    return Arity;

  })();

  ProcedureType = (function(superClass) {
    extend(ProcedureType, superClass);

    function ProcedureType(params, ret, options) {
      var defaultOptions, defaultVal, i, id, j, l, len, len1, param;
      if (options == null) {
        options = {};
      }
      if (!(this instanceof ProcedureType)) {
        return new ProcedureType(params, ret, options);
      }
      ProcedureType.__super__.constructor.call(this, {
        noConvert: true
      });
      id = 0;
      for (i = j = 0, len = params.length; j < len; i = ++j) {
        param = params[i];
        if (!(param instanceof Type)) {
          throw new Error("Procedure:param_" + i + "_not_type: " + param);
        }
      }
      if (!(ret instanceof Type)) {
        throw new Error("Procedure:ret_not_type: " + ret);
      }
      if (options.isVarArg) {
        if (!(params[params.length - 1] instanceof ArrayType)) {
          throw new Error("Procedure:vararg_require_last_param_to_be_array");
        }
      }
      if (options.defaultVals instanceof Array) {
        if (!params.length === options.defaultVals.length) {
          throw new Error("Procedure.default_Vals_not_equal_param_length: " + params.length + " != " + options.defaultVals.length);
        }
        for (i = l = 0, len1 = params.length; l < len1; i = ++l) {
          param = params[i];
          if (options.defaultVals[i] !== void 0) {
            defaultVal = _isFunction(options.defaultVals[i]) ? options.defaultVals[i]() : options.defaultVals[i];
            if (!param.isa(defaultVal)) {
              throw new Error("Procedure:default_val_" + i + "_not_match_type_" + param);
            }
          }
        }
      }
      defaultOptions = {
        typeID: typeID++,
        parameterTypes: params,
        returnType: ret,
        isVarArg: false
      };
      _mixin(this, _extend(defaultOptions, options));
    }

    ProcedureType.prototype.typeCategory = 'ProcedureType';

    ProcedureType.prototype.isGeneric = function() {
      var j, len, param, ref;
      ref = this.parameterTypes;
      for (j = 0, len = ref.length; j < len; j++) {
        param = ref[j];
        if (param.isGeneric()) {
          return true;
        }
      }
      return this.returnType.isGeneric();
    };

    ProcedureType.prototype.isComposite = function() {
      return false;
    };

    ProcedureType.prototype.isPrimitive = function() {
      return false;
    };

    ProcedureType.prototype.isTask = false;

    ProcedureType.prototype.resolve = function(obj, resolver) {
      if (obj.__$t) {
        return obj.__$t;
      } else {
        throw new Error("procedure_type_doesnt_support_resolve");
      }
    };

    ProcedureType.prototype.arity = function() {
      return new Arity(this.parameterTypes.length, this.isVarArg, this.defaultVals);
    };

    ProcedureType.prototype.normalize = function(args) {
      var arity;
      arity = this.arity();
      return arity.normalize(args);
    };

    ProcedureType.prototype.convertArguments = function(args) {
      var e, errors, i, j, len, normalized, param, ref, result;
      normalized = this.normalize(args);
      errors = [];
      result = [];
      ref = this.parameterTypes;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        param = ref[i];
        result.push(param._convert(normalized[i], errors));
      }
      if (errors.length > 0) {
        e = new Error("invalid_arguments: " + errors);
        e.errors = errors;
        throw e;
      } else {
        return result;
      }
    };

    ProcedureType.prototype.isa = function(obj) {
      if (obj.__$t === this) {
        return true;
      } else {
        return false;
      }
    };

    ProcedureType.prototype._toString = function(env) {
      var param, params;
      params = (function() {
        var j, len, ref, results;
        ref = this.parameterTypes;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          param = ref[j];
          results.push(param._toString(env));
        }
        return results;
      }).call(this);
      return "(" + (params.join(',')) + ") -> " + (this.returnType._toString(env));
    };

    return ProcedureType;

  })(Type);

  makeProc = function(argsTypes, retType, proc, options) {
    var procType;
    if (options == null) {
      options = {};
    }
    procType = ProcedureType(argsTypes, retType, options);
    _mixin(proc, {
      __$t: procType
    });
    return function() {
      var args, converted, res;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      converted = procType.convertArguments(args);
      res = proc.apply(null, converted);
      if (procType.returnType.isa(res)) {
        return res;
      } else {
        throw new Error("postcondition: " + res + " is not of type " + procType.returnType);
      }
    };
  };

  _mixin(Type, {
    createType: createType,
    attachType: attachType,
    makeProc: makeProc,
    makeDispatcher: UnaryDispatcher,
    makePrimitiveType: PrimitiveType,
    makeAnyType: AnyType,
    makeArrayType: ArrayType,
    makePropertyType: PropertyType,
    makeObjectType: ObjectType,
    makeOneOfType: OneOfType,
    makeProcedureType: ProcedureType,
    resolve: function(obj) {
      if (obj === void 0) {
        return UnitType;
      } else if (obj === null) {
        return NullType;
      } else if (typeof obj === 'number') {
        if (Math.floor(obj) === obj) {
          return IntegerType;
        } else {
          return FloatType;
        }
      } else if (obj.__$t instanceof Type) {
        return obj.__$t;
      } else if (obj.constructor.__$t instanceof Type) {
        return obj.constructor.__$t.resolve(obj, Type);
      } else {
        throw new Error("unknown_type: " + obj);
      }
    }
  });

  module.exports = Type;

}).call(this);
